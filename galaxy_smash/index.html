<!DOCTYPE html>
<html lang="en">
    <head>
        <title>SMASH</title>
    </head>
    <body>
            <script src="particle_physics.js"></script>
            <script src="three.min.js"></script>
            <script>
                var pi2 = Math.PI*2;
                var R0 = 50;
                var z0 = 10;
                var dt = 2;
                var eps = 10;
                var Pmass = 0;
                var mouse = new THREE.Vector3([1e7,1e7,1e7]);
                var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 3000 );
                camera.position.z = 1000;
                var scene = new THREE.Scene();

                var position = new THREE.Geometry();
                position.dynamic = true;
                var velocity = new Array();
                var gravity = function (pos) {
                    var accel = new THREE.Vector3();
                    var perturbator = new THREE.Vector3();
                    var offset = new THREE.Vector3();
                    offset.subVectors(pos, mouse);
                    perturbator.add(offset);
                    perturbator.normalize();
                    perturbator.multiplyScalar(-1.0*Pmass/(offset.lengthSq()+0.5*R0));
                    accel.add(pos);
                    accel.normalize();
                    accel.multiplyScalar(-1.0/(pos.length()));
                    accel.add(perturbator);
                    return accel;
                }

                //Generate the particles
                var rotation = new THREE.Euler(Math.random()*pi2, Math.random()*pi2, Math.random()*pi2, 'XYZ')
                for ( i = 0; i < 10000; i ++ ) {

                    var vertex = new THREE.Vector3();
                    var vel = new THREE.Vector3();
                    var theta = Math.random() * pi2;
                    var R = -Math.log(Math.random())*R0+eps;
                    vertex.x = R*Math.cos(theta);
                    vertex.y = R*Math.sin(theta);
                    vertex.z = 0;
                    //vel.x = -1*Math.sqrt(1./R)*Math.sin(theta);
                    //vel.y = Math.sqrt(1./R)*Math.cos(theta);
                    vel.x = -Math.sin(theta);
                    vel.y = Math.cos(theta);
                    vertex.applyEuler(rotation);
                    vel.applyEuler(rotation);
                    position.vertices.push( vertex );
                    velocity.push(vel);

                }

                var materials = new THREE.PointsMaterial( { size: 1, opacity:0.5, transparent:true, sizeAttenuation:false});
                particles = new THREE.Points( position, materials);
                scene.add( particles );
                renderer = new THREE.WebGLRenderer();
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );
                document.addEventListener('mousemove', onDocumentMouseMove, false);
                animate();
                function onDocumentMouseMove( event ) {
                    event.preventDefault();
                    mouse.x = event.clientX - 0.5*window.innerWidth;
                    mouse.y = -event.clientY + 0.5*window.innerHeight;
                    Pmass = 20;
                }
                function animate() {
                    requestAnimationFrame( animate );
                    renderer.render(scene, camera);
                    for (i in velocity)
                    {
                        velocity[i].addScaledVector(gravity(position.vertices[i]), 0.5*dt);
                    }
                    for (i in position.vertices)
                    {
                        position.vertices[i].addScaledVector(velocity[i], dt);
                    }
                    for (i in velocity)
                    {
                        velocity[i].addScaledVector(gravity(position.vertices[i]), 0.5*dt);
                    }
                    position.verticesNeedUpdate = true;
                }
            </script>
    </body>
</html>
